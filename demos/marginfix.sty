%%
%% This is file `marginfix.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% marginfix.dtx  (with options: `package')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from marginfix.sty.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file marginfix.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{marginfix}%
           [2010/06/14 v2.0 Fix Margin Paragraphs]
\makeatletter
\let\xa\expandafter
\chardef\@ight=8
\chardef\f@ur=4
\newcount\@C \@C=100

\def\sdh@debug{\@ifstar\@gobble\@gobble}
\def\sdh@debug@{\@ifstar\message{\message{^^J***}\message}}
\DeclareOption{debug}{\let\sdh@debug\sdh@debug@}

\newif\ifsdh@showphantoms
\DeclareOption{showphantoms}{\sdh@showphantomstrue}

\newif\ifsdh@invertshift
\DeclareOption{invertshift}{\sdh@invertshifttrue}
\ProcessOptions\relax

\RequirePackage{inlinedef}[2008/07/05]
\newdimen\@mparshift \@mparshift\z@
\newcount\floatsperpage
\floatsperpage\@ne %? what's a good value?  Should we use sth else?
\newbox\sdh@marginbox
\newtoks\sdh@marginlist
\newdimen\@marginheight
\newdimen\@marspace
\newdimen\@marboxspace % eventually this will be different from marspace,
                       % once we get the ``bubbling'' algorithm in
\newdimen\@marginextend \@marginextend\z@ % one-time extensions
\newcount\sdh@deadcycles
\let\sdh@marginphantom\@empty
\let\sdh@marginblock\relax
\let\sdh@floatcounts\@empty
\let\sdh@fl@pending\@empty
\let\sdh@fl@here\@empty
\let\sdh@fl@top\@empty
\let\sdh@fl@bottom\@empty
\let\sdh@fl@margin\@empty
\let\sdh@fl@defer\@empty
\def\sdh@fl@inline{\sdh@fl@here}
\let\sdh@ufilist\@empty
\newtoks\sdh@afterpage
\def\AfterPage#1{\global\sdh@afterpage\xa{\the\sdh@afterpage#1}}
\newif\ifsdh@floatfits
\newif\ifsdh@floatpage
\newif\ifsdh@floatbarrier\sdh@floatbarrierfalse
\newif\ifsdh@counterstepped
\newif\ifsdh@disorderfloat
 % This clobbers original value... :-/
 %\let\if@debug\undef\@gobble\fi % interesting problem - skip for now
 %\newif\if@debug%\@gobbletwo\fi\fi\@gobble\fi

\def\sdh@G@disorderedfloats{%
  \global\let\sdh@floats@disordered\sdh@floats@disordered@message}
\def\sdh@floats@disordered@message{%
  \@latex@warning@no@line{There were floats out of order.
    Rerun to fix figure numbers}}
\def\sdh@floats@disordered{%
  \global\let\sdh@G@disorderedfloats\sdh@floats@disordered@message
}
\AtEndDocument{\sdh@G@disorderedfloats}
\newcount\sdh@holdfloatnum
\newtoks\sdh@outputcode
\let\sdh@injectbox\relax
\let\sdh@latex@marginpar\marginpar
\def\marginpar{\begingroup
  \sdh@clearufilist
  \ifinner
    \sdh@error{Cannot call \protect\marginpar from an inner mode}\@eha
    \aftergroup\@gobble % some semblance of graceful error?
  \else
    \global\let\sdh@ufilist\@empty
    \aftergroup\sdh@latex@marginpar
  \fi
\endgroup}

\Inline*\def\@xympar{%
  %\sdh@debug{xympar}%
  \gdef\sdh@fl@inline{\sdh@fl@pending}%
  \sdh@addbox\@xympar}
\def\sdh@addbox{%
  \begingroup
    \sdh@debug{***adding a margin box: \@currbox/ \@marbox (shift \the\@mparshift)}%
    \let\ml@boxpre@repair\relax\let\ml@insert\relax
    \edef\@temp@{{\ml@insert\@currbox\@marbox{\ml@boxpre@repair{\the\@mparshift}}}}%
    \global\@mparshift\z@
    \marginsep{\the\marginparpush}% This is the easiest way to deal with pushing
    \xa\sdh@cons\xa\sdh@marginlist\@temp@
  \endgroup
}
\def\@addmarginpar{%
  \@next\@marbox\@currlist{}\sdh@bug
  \begingroup
    \sdh@debug{addmarginpar (running insert) \@marbox/\@currbox at \the\c@page:\the\@pageht}%
    %\sdh@showlists
    \let\ml@insert\ml@insert@run
    \let\ml@box\ml@box@save
    \let\ml@sep\ml@sep@save
    \let\ml@clear\ml@clear@save
    \sdh@runmarginlist
    %\sdh@showlists
  \endgroup
}
\def\@whichmarginbox#1#2{
  \@tempcnta\@ne
  \if@twocolumn
    \if@firstcolumn \@tempcnta\m@ne \fi
  \else
    \if@mparswitch
      \ifodd\c@page \else\@tempcnta\m@ne \fi
    \fi
    \if@reversemargin \@tempcnta -\@tempcnta \fi
  \fi
  \ifnum\@tempcnta <\z@
    \setbox\@tempboxa\copy#1%
  \else
    \setbox\@tempboxa\copy#2%
  \fi
}
\def\sdh@addtovbox#1#2{\global\setbox#1\vbox{\unvbox#1\nointerlineskip#2}}
\def\sdh@free#1{\xa\@cons\xa\@freelist#1}
\def\sdh@advancespace#1#2{%
  \global\advance#1\ht#2%
  \global\advance#1\dp#2%
}
\def\sdh@cons#1#2{%
  %\begingroup\def\@temp@{#2}\sdh@debug{sdh@cons \meaning\@temp@}\endgroup
  \global#1\xa{\the#1#2}}
\def\sdh@runmarginlist{%
  \toks@{}\the\sdh@marginlist\global\sdh@marginlist\toks@
}
\def\sdh@peek#1#2#3#4{\ifx#2\@empty #4\else
   \expandafter\sdh@xpeek #2\@@#1#2#3\fi}
\def\sdh@xpeek \@elt #1#2\@@#3#4{\gdef#3{#1}}
\def\mk@marginbox{%\begingroup
  %\@marspace\z@
  %\@marboxspace\z@
  %% We use one conditional for this process:
  %% \@tempswa ...
  %% What are they for...?
  \let\ml@box\ml@box@build
  \let\ml@insert\ml@insert@save
  \let\ml@sep\@gobble % Just for now -> first \ml@box fixes it
  \let\ml@clear\ml@clear@build
  %\showthe\sdh@marginlist
  \sdh@debug{mk@marginbox: marginheight=\the\@marginheight}%
  \@temptokena{}\sdh@runmarginlist
  % for the last group of boxes on a page only, we want to maybe add a sep
  % if there's extra unused space, for aesthetic reasons.
  % THIS SHOULD BE OPTIONAL! (\flushmargin vs \raggedmargin?)
  \if@tempswa \ifdim\ht\@outputbox<\@colroom
    \xa\ml@sep@build\xa{\the\dimexpr\@colroom-\ht\@outputbox}%
  \fi \fi
  %\sdh@debug{marginheight: \the\@marginheight}%
  %\showthe\@temptokena
  \ml@bubble@setup
  %\global\setbox\sdh@marginbox\vbox{\vskip-\marginparpush}%
  \toks@{}\the\@temptokena
  %\showthe\toks@
  \global\setbox\sdh@marginbox\vbox{\unvbox\sdh@marginbox\the\toks@}
  %\endgroup
}

\def\sdh@marginnext{%
  \@next\@phantombounds\sdh@marginphantom{% should we check sanity of bounds?
    \@tempswafalse % not last block
    %\sdh@debug{ \@phantombounds}%
    \xa\xa\xa\@marginheight\xa\@firstoftwo\@phantombounds
    %\sdh@debug{MAKE SEGMENT^^J***marginheight: \the\@marginheight}%
    \mk@marginbox
    \@marspace\ht\sdh@marginbox % let's just ask...
    \xa\@tempdima\xa\@secondoftwo\@phantombounds
    %\sdh@debug*{, marspace: \the\@marspace, new start: \the\@tempdima}%
    \@marboxspace\@tempdima
    \advance\@tempdima-\@marspace % as far as we got
    %\sdh@debug*{, gap: \the\@tempdima}%
    \@marspace\@marboxspace % funny ordering...
    \global\setbox\sdh@marginbox\vbox{\unvbox\sdh@marginbox\vskip\@tempdima}
    \sdh@marginnext
  }{%
    \@tempswatrue % last block
    \xa\global\xa\@marginheight\sdh@totalmarginheight
    \mk@marginbox
  }%
}
 % @@@ Need to check: if there's a pending blockmargin then we should
 % act like the bottom of the page is the unblock, then replace the block
 % at the top of the next page...!
\def\sdh@buildmargin{% assembles margin material into \sdh@marginbox
  \begingroup
  %\traceon
  %\showthe\sdh@marginlist
  %\sdh@calculatephantoms
  \sdh@sortphantoms
  \sdh@showphantoms
  %\@marginheight\ht\@outputbox
  %%% CHECK THAT COLROOM RESPECTS [B] FLOATS!
  % For now, we'll assume every box blocks...
  \@marginheight\dimexpr\@colroom+\@marginextend\relax
  \global\@marginextend\z@
  \edef\sdh@totalmarginheight{\the\@marginheight}%
  \@marspace\z@
  \@marboxspace\z@ % start here...
  \global\setbox\sdh@marginbox\vbox{}%
  \sdh@marginnext
  \global\let\sdh@marginphantom\@empty
  %%%\mk@marginbox
  %\@tempdima\ht\@outputbox
  %\global\ht\sdh@marginbox\@tempdima
  % now that we're done, we'll reset the #3 args to 0pt:
  \global\let\ml@box\ml@box@cleared
  \global\let\ml@insert\ml@insert@save
  \global\let\ml@sep\ml@sep@save
  \global\let\ml@clear\ml@clear@save
  \sdh@runmarginlist % now \sdh@marginbox is loaded...
  % Need to correct the height now...
  %%%%%%%% @@@@@@@ IS THIS OKAY?!?!?!?!?
  \ifdim\ht\sdh@marginbox>\textheight
    \@tempdima\dimexpr\ht\sdh@marginbox+\dp\sdh@marginbox-\textheight\relax
    \ht\sdh@marginbox\textheight
    \dp\sdh@marginbox\@tempdima
  \fi
  %
  \endgroup
}
\let\@shipout\shipout
\Inline*\def\@combinefloats{%
  %\sdh@debug{botlist: \meaning\@botlist}%
  % This is called by \@makecol in the OR.
  % Want to intercept right before combining floats from top/bottom into
  % \@outputbox so that we can find out if any overflow into the margin...
  %\sdh@calculatephantoms % for  now, just assume they conflict...
  \begingroup
  %\message{^^J===CF: \sdh@fl@bottom // \@botlist}%
  \sdh@foreach\@botlist\sdh@tryfullwidth
  \endgroup
  \sdh@debug{@combinefloats}\sdh@showlists
  \sdh@combinemargin@i % sdh 5/18 why is this here - it seems to break things!
  %%% \__/ this was here so that we could enlarge the page if needed, pushing
  %%%    \ the [b] floats down some...
  %\sdh@debug{toplist: \meaning\@toplist}%
  \@combinefloats
  % SDH 5/19/08 At this point I believe everything's added (including footnotes)
  % so we are free to push stuff up...
  %%% NEW CODE 6/5/08
  \ifdim\ht\@outputbox<\@colht % I think we want to do this...
 %%%%% \global\let\shipout\@shipout % DEBUG -> only shipout interesting pages
    \setbox\@outputbox\vbox to\@colht{\unvbox\@outputbox\vskip-\lastskip}%
 %   \ifnum\badness>\@C %%%%% \XXX% does this ever happen?????
 %     \setbox\@outputbox\vbox to\@colht{\unvbox\@outputbox\vfil}% %???
 %   \fi
  \fi
}
\def\sdh@sortphantoms{\begingroup
  % this is pretty primitive, but should make it at least workable...
  % \if@tempswa is used here to note whether the lowest point was
  %   a block or an unblock...
  \dimen@-1\p@
  \@tempswafalse % not blocking
  \let\@temp@\@empty
  \def\@elt##1{%
    \xa\@tempdima\@firstoftwo##1%
    \xa\@tempdimb\@secondoftwo##1%
    \if@tempswa\else % not currently blocking
      \ifnum\@tempdima>\dimen@
        \@tempswatrue
        \dimen@\@tempdima
      \fi
    \fi
    \if@tempswa % currently blocking
      \ifnum\@tempdimb>\dimen@
        \@tempswafalse
        \edef\@temp@@{{{{\the\dimen@}{\the\@tempdimb}}}}%
        \xa\@cons\xa\@temp@\@temp@@%
      \fi
    \fi
  }%
  \sdh@marginphantom
  \ifx\sdh@marginblock\relax
    \edef\@temp@@{{{{\sdh@marginblock}{\the\textheight}}}}%
    \xa\@cons\xa\@temp@\@temp@@%
    \sdh@marginblock\z@\p@ % reset to top of new page
  \else\if@tempswa
    \edef\@temp@@{{{{\the\dimen@}{\the\textheight}}}}%
    \xa\@cons\xa\@temp@\@temp@@%
  \fi\fi
  \let\sdh@marginphantom\@temp@
  \endgroup
}
\def\sdh@calculatephantoms{\begingroup
  % This routine is NOT currently used...
  % IDEA: look at the float lists for [t] and [b] and figure out which
  % are oversized - if any are oversized then insert a marginphantom to
  % deal with it.
  % Difficulty: we want to call this while the boxes still exist so that
  % we can find out their sizes...  but widths probably can't be trusted,
  % unless we can be really clever.  Maybe hook into the beginning of
  % \@combinefloats (called near end of \@makecol)...  we could do
  % \begingroup\sdh@foreach\sdh@fl@bottom\tryfullwidth\endgroup between.
  % ... some of this stuff is slow - maybe have options to turn these
  %     routines on/off?
  \@tempdima\z@ % top of current box
  \@tempdimb\z@ % bottom of current box
  % Start with \sdh@fl@top...
  \def\go##1##2##3##4{% all we need is dimens of 4
    %\message{^^J======go{##1}{##2}{##3}{##4}}%
    %\message{^^J======wd##4=\the\wd##4 cf ##2}%
    \if@tempswa % currently blocking
      \message{ -> blocking}%
      \advance\@tempdimb\dimexpr\ht##4+\dp##4\relax%
      \ifdim\wd##4>\columnwidth\else % this one fits
        \message{ -> fits}%
        \edef\@temp@{{{{\the\@tempdima}{\the\@tempdimb}}}}%
        \xa\@cons\xa\newphants\@temp@
        \@tempswafalse
      \fi
    \else % not blocking
      \message{ -> not blocking}%
      \message{ (\the\wd##4)}%
      \ifdim\wd##4>\columnwidth % but this one doesn't fit
        \message{ -> too big}%
        \@tempdima\@tempdimb
        \@tempswatrue
      %\else\message{^^J======\the\wd##4 < \the\columnwidth}%
      \fi
      \advance\@tempdimb\dimexpr\ht##4+\dp##4\relax%
    \fi
    \advance\@tempdimb\floatsep
  }
  % This code to be tested when I implement [t] floats!
 %%   \let\newphants\@empty
 %%   \@tempswafalse % not blocking initially...
 %%   \sdh@foreach\sdh@fl@top\go
 %%   \advance\@tempdimb-\floatsep % take off last floatsep
 %%   % (do we add \textfloatsep yet?)
 %%   \if@tempswa % still blocking
 %%     \edef\@temp@{{{{\the\@tempdima}{\the\@tempdimb}}}}%
 %%     \xa\@cons\xa\newphants\@temp@
 %%   \fi
 %%   \advance\@tempdimb\textfloatsep
 %%   \sdh@cat\sdh@marginphantom:=\newphants\sdh@marhinphantom
  % Now go through entire margin and add \@tempdimb to EVERYTHING
  % including box positions and current phantoms...  how?
  \advance\@tempdimb\ht\@outputbox % \@pageht? \@colroom?
  %\message{^^J===: \the\@pageht // \the\ht\@outputbox // \the\@colroom}%
  \advance\@tempdimb\textfloatsep
  %
  \let\newphants\@empty
  \@tempswafalse
  \sdh@foreach\sdh@fl@bottom\go
  \advance\@tempdimb-\floatsep
  \if@tempswa % still blocking
    \edef\@temp@{{{{\the\@tempdima}{\the\@tempdimb}}}}%
    \xa\@cons\xa\newphants\@temp@
  \fi
  \ifx\newphants\@empty
    %\message{^^J===NO NEW PHANTOMS ADDED}%
  \else
    %\message{^^J===NEW PHANTOMS ADDED: \newphants}%
  \fi
  \sdh@cat\sdh@marginphantom:=\sdh@marginphantom\newphants
  \endgroup
  %\message{^^J=== -> \sdh@marginphantom}%
}
\def\sdh@showphantoms{%
  \begingroup
  \ifx\sdh@marginphantom\@empty
    \sdh@debug{No phantoms on page \the\c@page}%
  \else
    \sdh@debug{Phantoms on page \the\c@page:}%
    \def\@elt##1{\sdh@debug{\@firstoftwo##1 - \@secondoftwo##1}}%
    \sdh@marginphantom
  \fi
  \endgroup
}
\def\ml@box#1#2#3{\sdh@bug}
\def\ml@insert#1#2#3{\sdh@bug}
\def\ml@clear{\sdh@bug}
\def\ml@sep#1{\sdh@bug}
\def\sdh@marginfull{%
  \global\let\ml@box\ml@box@save %%%@cleared
  \global\let\ml@insert\ml@insert@save
  \global\let\ml@sep\ml@sep@save
  \global\let\ml@clear\ml@clear@save
}
\def\ml@box@build#1#2#3{%
  \sdh@debug{#1--#2: #3}%
  \let\ml@sep\ml@sep@build
  \ifdim\@marspace<#3\relax
    \@tempdima#3\relax
    \advance\@tempdima-\@marspace
    \sdh@debug{Adding \the\@tempdima\space padding to margin}%
    \global\advance\@marspace\@tempdima
    \xa\sdh@cons@backward\xa\@temptokena\xa
        {\xa\ml@glue@bubble\xa{\the\@tempdima}}%
  \fi
  \@whichmarginbox#1#2%
  %\setbox\count@\hbox{#3: #1---#2}%
  \dimen@\dimexpr(\ht\@marbox+\dp\@marbox)\relax
  \sdh@debug*{--> \the\dimen@}%
  \advance\@marspace\dimen@
  \advance\@marboxspace\dimen@
  \ifdim\@marboxspace > \@marginheight % too big
    % We might want to see if the box is >\textheight and issue an error
    % We might also want to wait a page or two in case of \extendmargin
    \global\advance\@marspace\dimexpr-\dp\@marbox-\ht\@marbox\relax
    \sdh@marginfull
    \ml@box@save#1#2{#3}% changed from 0pt - we'll do that later...
  \else
    \xa\sdh@cons@backward\xa\@temptokena\xa{\xa\ml@box@bubble\@marbox}%
    \sdh@debug{Building box #1/ #2}%
    % We need to move this box from pending to margin list -> #2=\@currbox
    %\sdh@debug{BOX@BUILD:}%
    %\sdh@debug{pending: \sdh@fl@pending^^J***here: \sdh@fl@here}%
    %\sdh@debug{defer: \sdh@fl@defer^^J***margin: \sdh@fl@margin^^J}%
    \sdh@move#1\sdh@fl@pending\sdh@fl@margin
    %\sdh@addtovbox\sdh@marginbox{\box\@tempboxa}%
    \sdh@free#1\sdh@free#2%
  \fi
}

\def\ml@sep@build#1{%
  \global\advance\@marspace#1\relax
  \global\advance\@marboxspace#1\relax
  \ifdim\@marboxspace > \@marginheight
    \global\advance\@marspace-#1\relax
    \global\advance\@marboxspace-#1\relax
    %\ml@sep@save{#1}% shouldn't matter - will get erased.
    \sdh@marginfull
  \else
    \sdh@cons@backward\@temptokena{\ml@sep@bubble{#1}}%
  \fi
}

\def\ml@clear@build{%
  \if@tempswa\else % there's more blocks coming...
    \ml@clear@save % save this so the next block clears too
    \global\let\sdh@marginphantom\@empty % skip remaining parts
  \fi
  \sdh@marginfull
  %\sdh@debug{TOKS: \the\toks@^^J***TEMPTOKSA: \the\@temptokena}%
  %\sdh@debug{MARGINLIST: \the\sdh@marginlist}%
}

\def\sdh@cons@backward#1#2{%
  \begingroup\def\@temp@{#2}%
  \global#1\xa\xa\xa{\xa\@temp@\the#1}\endgroup
}

\def\@whichmarginbox#1#2{
  % returns correct box in \@marbox
  % We can't destroy either since we're not sure it'll fit yet
  \@tempcnta\@ne
  \if@twocolumn
    \if@firstcolumn \@tempcnta\m@ne \fi
  \else
    \if@mparswitch
      \ifodd\c@page \else\@tempcnta\m@ne \fi
    \fi
    \if@reversemargin \@tempcnta -\@tempcnta \fi
  \fi
  \ifnum\@tempcnta <\z@ \def\@marbox{#1}\else \def\@marbox{#2}\fi
}
\def\ml@bubble@setup{%
  \global\@marboxspace\z@ % reuse for extra space
  \ifdim\@marspace>\@marginheight
    \global\@marboxspace\@marspace
    \global\advance\@marboxspace-\@marginheight
  \fi
}
\def\ml@box@bubble#1{% NOTE the fewer arguments
  \sdh@cons@backward\toks@{\nointerlineskip\box#1\nointerlineskip}%
}
\def\ml@sep@bubble#1{%
  \sdh@cons@backward\toks@{\vskip#1}%
}
\def\ml@glue@bubble#1{%
  \ifdim\@marboxspace>\z@
    \ifdim\@marboxspace>#1\relax
      \global\advance\@marboxspace-#1\relax
    \else
      \@tempdima#1\relax
      \advance\@tempdima-\@marboxspace
      \xa\sdh@cons@backward\xa\toks@\xa{\xa\vskip\the\@tempdima}%
      \global\@marboxspace\z@
    \fi
  \else
    \sdh@cons@backward\toks@{\vskip#1}%
  \fi
}
\def\ml@boxpre@repair#1{%
  \sdh@debug{Repairing box: \@marbox, shift #1}%
  \@tempdima\dimexpr#1+\@pageht-\baselineskip
  \sdh@debug*{ => \the\@tempdima}
  \begingroup
    \edef\@temp@{\@marbox\@currbox{\the\@tempdima}}%
    \xa\sdh@cons\xa\toks@\xa{\xa\ml@box\@temp@}%
  \endgroup
  %\let\ml@code\ml@code@repair\let\ml@skip\ml@skip@repair
}

\def\ml@insert@run#1#2#3{% #3=code, #1,#2=boxes to free
  %\sdh@debug{Checking to run insert #1#2 (looking for \@marbox\@currbox)}%
  \ifnum#1=\the\@marbox\sdh@debug*{ => PASS}%
    #3%\sdh@free#2\sdh@free#3% don't free here!!!
  \else
    \sdh@cons\toks@{\ml@insert#1#2{#3}}
  \fi
}
\def\ml@box@save#1#2#3{\sdh@cons\toks@{\ml@box{#1}{#2}{#3}}}
 % We put an \sdh@marginfull here b/c if it all runs before the box
 % is repaired, we need to make sure the sep's get saved.
\def\ml@insert@save#1#2#3{\sdh@marginfull\sdh@cons\toks@{\ml@insert#1#2{#3}}}
\def\ml@sep@save#1{\sdh@debug{saving sep #1}\sdh@cons\toks@{\ml@sep{#1}}}
\def\ml@clear@save{\sdh@cons\toks@\ml@clear}
 %\let\ml@box@cleared\ml@box@save % we'll reset it later
\def\ml@box@cleared#1#2#3{\ml@box@save{#1}{#2}{0pt}}
 % Clearpage is supposed to dump floats
 % If it's called explicitly in the middle of a page on which we've decided to
 % put a [b] float, then \@doclearpage gets ahold of it and defers it with
 % LaTeX's deferlist.  But we don't want that to happen, so we have to hijack
 % the clearpage and make sure we dump our own floats FIRST!
\let\sdh@clearpage\clearpage
\def\clearpage{\dumpfloats\sdh@clearpage}
\def\dumpfloats{%
  \global\sdh@deadcycles\z@
  \sdh@floatbarriertrue
  \sdh@clearpage
  \begingroup % move everything back to defer list
    % If there's anything left here, it's probably a bug!
    %\@testfalse
    %\def\@elt##1{\@testtrue}%
    %\sdh@fl@top\sdh@fl@here\sdh@fl@bottom
    %\if@test
    %  \sdh@error{dumpfloats: clearpage didn't do its job with ##1}\@eha
    %\fi
    % DID WE LOSE ANYTHING?
    % But otherwise move stuff (this code here shouldn't be needed...!)
    \let\@elt\relax
    \xdef\sdh@fl@defer{\sdh@fl@top\sdh@fl@here\sdh@fl@bottom\sdh@fl@defer}%
    \global\let\sdh@fl@top\@empty\global\let\sdh@fl@here\@empty
    \global\let\sdh@fl@bottom\@empty
  \endgroup
  \sdh@countall
  \ifsdh@floatbarrier\else\sdh@debug{dumpfloats: nothing to dump!}\fi
  \@whilesw\ifsdh@floatbarrier\fi{%
    \sdh@debug{dumpfloats: \the\sdh@deadcycles}
    \vfill\filbreak\sdh@clearpage\sdh@countall
    \sdh@deadcycle
}}
\AtEndDocument{\dumpfloats}
\def\sdh@deadcycle{%
  \advance\sdh@deadcycles\@ne
  \ifnum\sdh@deadcycles>\sixt@@n
    \sdh@showlists
    \sdh@error{Can't seem to dump all the floats}\@eha
    \global\sdh@fl@pending\@empty %%% this is probably as graceful as we can be?
  \fi
}
\def\sdh@countall{%
  \sdh@floatbarrierfalse
  \begingroup
    % First count the floats
    \sdh@debug{Counting floats}%
    \def\@elt##1{\advance\count@\@ne}%
    \count@\z@                  % At this point, we've manually emptied others
    \sdh@fl@defer\sdh@fl@margin\sdh@fl@pending % probably don't want all these
    % Check if we had any
    \sdh@debug*{-> \the\count@}%
    \ifnum\count@>\z@\global\sdh@floatbarriertrue\fi
    % Now count the margin notes
    \def\ml@box##1##2##3{\advance\count@\m@ne}%
    \let\ml@boxpre\ml@box
    \let\ml@sep\@gobble\let\ml@clear\relax
    \the\sdh@marginlist
    % If all the floats are marginal than output a box
    \ifnum\count@=\z@\ifsdh@floatbarrier
      \sdh@debug*{-> all marginal}%
      \setbox\z@\vbox{}\ht\z@\@colht\wd\z@\textwidth\box\z@
    \else\sdh@debug*{-> \the\count@ non-marginal}%
    \fi\fi
  \endgroup
  \sdh@showlists
}
\newcommand\mparshift[1]{%
  \@mparshift#1%
}
\def\marginsep#1{\begingroup
  \edef\@temp@{{#1}}% length gets expanded immediately...
  \xa\sdh@cons\xa\sdh@marginlist\xa{\xa\ml@sep\@temp@}\endgroup
}
\def\marginskip#1{\marginpar{\vbox{\vskip #1}}}
\def\clearmargin{\sdh@cons\sdh@marginlist\ml@clear}
\def\softclearmargin{\marginsep{\the\textheight}}
\def\extendmargin#1{\advance\@marginextend#1\relax}
\def\inject#1{%
 % \ifvmode \sdh@warning{\string\inject\space should not be used in %
 %   vertical mode mode: extra spaces may result}%
 %   \leavevmode
 % \fi
  \ifinner \sdh@error{\string\inject\space can only be used in %
        unrestricted horizontal mode}\@eha%
  \else
    \begingroup
      \edef\temp@{\the\sdh@outputcode}% could also check \sdh@injectbox?
      \ifx\temp@\@empty
        \ifx\sdh@injectbox\relax\else\sdh@error{Injection lost}\@eha\fi
        \global\sdh@outputcode{#1}%
        \sdh@peek\sdh@injectbox\@freelist\relax\relax % if empty then float dies
        % We could alternately insert our OWN insertion onto freelist...
        \begin{figure}[p]\end{figure}%
      \else
        \sdh@warning{Injections colliding on page \the\c@page}%
        \global\sdh@outputcode\xa{\the\sdh@outputcode#1}%
      \fi
    \endgroup
    %\penalty-10005%\@Mv\penalty-\@Miv
    %\marginpar{}%
  \fi
}
\def\flushfloat{% % check hmode...
  \penalty-\@Miv\vbox{}\penalty-\@Miii
}
\outer\def\AllowDisorderedFloat#1{%
  \xa\gdef\csname ftype@#1\endcsname{0}%
}
\def\blockmargin{%
  \sdh@debug{blockmargin}%
  \inject{%
    \sdh@debug{OR: blockmargin}%
    \ifx\sdh@marginblock\relax
      \xdef\sdh@marginblock{\the\@pageht}%
      \sdh@debug{Blocking margin: \meaning\sdh@marginblock}%
    \else\sdh@error{Extra \string\blockmargin}\@eha\fi
  }%
  \@ifstar\softclearmargin\relax
}

\def\unblockmargin{%
  \sdh@debug{unblockmargin}%
  \inject{%
    \sdh@debug{OR: unblockmargin}%
    \ifx\sdh@marginblock\relax
      \sdh@error{\string\unblockmargin\space without \string\blockmargin}\@eha%
    \else
      \begingroup
        \ifdim\sdh@marginblock<\the\@pageht
          \edef\@temp@{{{{\sdh@marginblock}{\the\@pageht}}}}%
          \xa\@cons\xa\sdh@marginphantom\@temp@
        \else
          \sdh@debug{nonsense phantom supressed}%
        \fi
      \endgroup
      \sdh@debug{Unblocking margin: \meaning\sdh@marginphantom}%
    \fi
    \global\let\sdh@marginblock\relax
  }%
}
\def\marginphantom#1#2{%
  \sdh@debug{marginphantom(#1)(#2)}%
  \inject{%
    \sdh@debug{OR: marginphantom(#1)(#2)}%
    \begingroup
      \edef\@temp@{{%
          {{\the\dimexpr\@pageht+#1}{\the\dimexpr(@pageht+#2}}%
      }}\xa\@cons\xa\sdh@marginphantom\@temp@
    \endgroup
  }%
}
\def\same#1#2{00\fi\ifAllChars#1$\Are#2$\TheSame}
\def\ifAllChars#1#2\Are#3#4\TheSame
   {\if#1$\if#3$\say{true}%
          \else \say{false}\fi
    \else \if#1#3\ifRest#2\TheSame#4\else
                 \say{false}\fi\fi}
\def\ifRest#1\TheSame#2\else#3\fi\fi
   {\fi\fi \ifAllChars#1\Are#2\TheSame}
\def\say#1#2\fi\fi
   {\fi\fi\csname if#1\endcsname}
\def\@push#1#2{\begingroup\let\@elt\relax\xdef#1{\@elt #2#1}\endgroup}
\def\sdh@cat#1:=#2#3{\begingroup\let\@elt\relax\xdef#1{#2#3}\endgroup}
\def\sdh@swapcounters#1#2{\@tempcnta#1\relax#1#2\relax#2\@tempcnta}
\def\@firstoffour#1#2#3#4{#1}
\def\@secondoffour#1#2#3#4{#2}
\def\@thirdoffour#1#2#3#4{#3}
\def\@fourthoffour#1#2#3#4{#4}
\def\sdh@warning{\PackageWarning{floatprobsbegone}}
\def\sdh@error{\PackageError{floatprobsbegone}}
 % These seem to work given if@debug
 %\def\sdh@debug{\if@debug\xa\sdh@debug@\fi}
 %\def\sdh@debug@{\@ifnextchar*\message{\message{^^J***}\message}}

 % This seems to work well...
 %\def\sdh@debug@{\@ifnextchar*{\@firstoftwo\message}{\message{^^J***}\message}}
 %\def\sdh@debug@on{\let\sdh@debug\sdh@debug@}
 %\def\sdh@debug@off{\let\sdh@debug\@gobble}
 %\sdh@debug@on
\def\sdh@move#1#2#3{% Moves box #1 from #2 into #3
  \begingroup
  \xa\let\xa\@currbox#1%
  \def\@elt##1{%
    \xa\ifx\@fourthoffour##1\@currbox
      \@cons#3{{##1}}%
    \fi
  }#2%
  \def\@elt##1{%
    \xa\ifx\@fourthoffour##1\@currbox\@gobble\relax\else
      \noexpand\@elt{##1}%
    \fi
  }\xdef#2{#2}%
  \endgroup
}

\def\sdh@movefront#1#2#3{% Moves box #1 from #2 into the front of #3
  \begingroup
  \xa\let\xa\@currbox#1%
  \def\@elt##1{%
    \xa\ifx\@fourthoffour##1\@currbox
      \@push#3{{##1}}%
    \fi
  }#2%
  \def\@elt##1{%
    \xa\ifx\@fourthoffour##1\@currbox\@gobble\relax\else
      \noexpand\@elt{##1}%
    \fi
  }\xdef#2{#2}%
  \endgroup
}
\def\sdh@make@ufi{\@captype:\csname sdh@c@\@captype\endcsname}
\def\sdh@checkbit#1#2{% returns the #1 bit of #2
  \begingroup
    \count@#2\divide\count@#1%
    \ifodd\count@
      \aftergroup\@testtrue
    \else
      \aftergroup\@testfalse
    \fi
  \endgroup
}
\def\sdh@showlists{%
  \sdh@debug{pending: \sdh@fl@pending}%
  \sdh@debug{top: \sdh@fl@top}%
  \sdh@debug{here: \sdh@fl@here}%
  \sdh@debug{bottom: \sdh@fl@bottom}%
  \sdh@debug{defer: \sdh@fl@defer}%
  \sdh@debug{currlist: \@currlist}%
  \sdh@debug{margin: \sdh@fl@margin}%
  \sdh@debug{marginlist: \the\sdh@marginlist}%
}
\def\sdh@vmodeonly#1{%
  \ifhmode\sdh@error{\string#1\space cannot be used in hmode}\@eha\fi}
\def\sdh@getcount#1#2{% #1=counter; #2=floattype e.g. figure
  \let\@save@elt\@elt
  \def\@elt##1{\xa\if\xa\same\xa{\@firstoftwo##1}{#2}%
    \@secondoftwo##1\fi}%
  \xa#1\xa0\sdh@floatcounts\relax
  \let\@elt\@save@elt
}
\def\sdh@stepcount#1{% #1=floattype, e.g. figure
  \begingroup
    \xa\let\xa\@temp@\csname the#1\endcsname
    \sdh@getcount\@tempcnta{#1}%
    \def\@elt##1{%
      \xa\if\xa\same\xa{\@firstoftwo##1}{#1}\else\noexpand\@elt{##1}\fi
    }%
    \advance\@tempcnta\@ne
    \xdef\sdh@floatcounts{\sdh@floatcounts\noexpand\@elt{{#1}{\the\@tempcnta}}}%
  \endgroup
}
\def\sdh@zerocounters{%
  \begingroup
    \def\@elt##1{\noexpand\@elt{\@firstoftwo##1}{0}}%
    \xdef\sdh@floatcounts{\sdh@floatcounts}%
  \endgroup
}
\def\sdh@zerocounter#1{%
  \begingroup
    \def\@elt##1{\noexpand\@elt{{\@firstoftwo##1}{%
        \xa\if\xa\same\xa{\@firstoftwo##1}{#1}0\else\@secondoftwo##1\fi}}}%
    \xdef\sdh@floatcounts{\sdh@floatcounts}%
  \endgroup
}

 % This could be made more useful by allowing custom floats to be added
\def\sdh@floatnums{figure: \the\c@figure}%, storybox: \the\c@storybox}
\def\sdh@combinemargin@i{%
  % This runs BEFORE we combine the floats
  \sdh@buildmargin
  % Are we giving up the chance to stretch the outputbox here?!?
  % ...maybe - but we need this to make sure that a full-width box
  %    doesn't collide with a descended margin note.
  \ifdim\ht\sdh@marginbox<\ht\@outputbox\else % We deal with this case later
    % Add an extra vskip to bottom of \@outputbox!!!
    \begingroup
    \@tempdima\ht\@outputbox
    % First try to stretch
    \global\setbox\@outputbox\vbox to \ht\sdh@marginbox{\unvbox\@outputbox}%
    \ifnum\badness>\@C
      \global\setbox\@outputbox\vbox to \ht\sdh@marginbox{%
        \unvbox\@outputbox\vfil % insert glue instead
      }
    \fi
    \endgroup
  \fi
}
\def\sdh@combinemargin@ii{%
  % This runs AFTER we combine the floats...
  \ifdim\ht\sdh@marginbox<\ht\@outputbox
    % This will get complicated when we have [t] floats because it will
    % push the margin box too high.  We'd rather have all this up top but
    % that seems to cause extra space for some reason.  Also, we'd like
    % to know when we have free space above/below due to non-oversized
    % floats, and take advantage of that!  Maybe shift everything by the
    % height of the topbox...?  split \@combinefloats into multiple parts?
    \global\ht\sdh@marginbox\ht\@outputbox
  \fi
  \ifdim\wd\@outputbox>\columnwidth % emit a warning if it's too big
    \sdh@warning{Main column width on page \the\c@page\space too large by%
      \the\dimexpr\wd\@outputbox-\columnwidth}%
  \fi
  \wd\@outputbox\columnwidth % make sure always same width!
  \ifodd\c@page
    \setbox\@outputbox\vbox{\hbox{%
      \box\@outputbox
      \rlap{\hskip\marginparsep\box\sdh@marginbox}}}%
  \else
    \setbox\@outputbox\vbox{\hbox{%
      \llap{\box\sdh@marginbox\hskip\marginparsep}%
      \box\@outputbox}}%
  \fi
}
\Inline*\def\@outputpage{%
  \sdh@combinemargin@ii % sdh 5/18 I found this commented, but why?!?
  % above was copied from margin part
  \sdh@renumberfigures
  \sdh@build@tb
  \@outputpage
  \the\sdh@afterpage % do we want/need this?!
  %\global\@colroom\textheight % will somebody else do this?
  \global\sdh@floatpagetrue
  \global\sdh@afterpage{}%
  %%%%%%\gdef\shipout{\setbox\@tempboxa}% %%%@@@@@
}
\def\@xtryfc #1{%
  \sdh@debug{@xtryfc testing box #1 (ht=\the\ht#1)}%
  \@next\reserved@a\@trylist{}{}%
  \@currtype \count #1%
  \divide\@currtype\@xxxii
  \multiply\@currtype\@xxxii
  \@bitor \@currtype \@failedlist
  \if@test\sdh@debug*{ -> failed bitor}\fi
  \if@test\else
    \@testfp #1%
    \if@test\sdh@debug*{ -> failed [p]}\fi
  \fi
  \ifdim \ht #1>\@colht
    \sdh@debug*{ -> too big}%
    \@testtrue
  \fi
  \if@test
    \sdh@debug*{ -> failed}%
    \@cons\@failedlist #1%
  \else
    \@ytryfc #1%
  \fi}
\def\@ytryfc #1{%
  \sdh@debug{@ytryfc testing box #1}%
  \begingroup
    \gdef\@flsucceed{\@elt #1}%
    \global\let\@flfail\@empty
    \@tempdima\ht #1%
    \let\@elt\@ztryfc
    \@trylist
    \ifdim \@tempdima >\@fpmin
    \sdh@debug*{ -> made column}%
    \global\@fcolmadetrue
  \else
    \sdh@debug*{ -> too small (\the\@tempdima < \the\@fpmin)}%
    \@cons\@failedlist #1%
  \fi
  \endgroup
  \if@fcolmade
    \let\@elt\@gobble
  \fi}
\def\@ztryfc #1{%
  \sdh@debug{@ztryfc on box #1}%
  \@tempcnta \count#1%
  \divide\@tempcnta\@xxxii
  \multiply\@tempcnta\@xxxii
  \@bitor \@tempcnta {\@failedlist \@flfail}%
  \if@test\sdh@debug*{ -> failed bitor \the\@tempcnta}\fi
  \if@test\else\@testfp #1\if@test\sdh@debug*{ -> failed [p]}\fi\fi
  \@tempdimb\@tempdima
  \advance\@tempdimb \ht#1%
  \advance\@tempdimb\@fpsep
  \ifdim \@tempdimb >\@colht
    \sdh@debug*{ -> too big (\the\@tempdimb > \the\@colht)}%
    \@testtrue
  \fi
  \if@test
    \sdh@debug*{ -> doesn't fit}%
    \@cons\@flfail #1%
  \else
    \sdh@debug*{ -> adding to page}%
    \@cons\@flsucceed #1%
    \@tempdima\@tempdimb
  \fi}
\renewcommand\@wtryfc[1]{%
  \global\setbox\@outputbox\vbox{%
    \unvbox\@outputbox
    \vskip\@fpsep%
    \sdh@tryfullwidth#1%
    \box#1%
  }%
}%
\def \sdh@old@tryfcolumn #1{%
  \sdh@debug{\string\@tryfcolumn (\string\@fpmin=\the\@fpmin): }%
  \global \@fcolmadefalse
  \ifx #1\@empty
    \sdh@debug*{defer list empty}%
  \else
    \sdh@debug*{defer list: \meaning#1}%
     \xdef\@trylist{#1}%
     %%%%%%%%%%%%\global \let \@failedlist \@empty
     \sdh@map\@failedlist<-\@fourthoffour{\sdh@fl@top\sdh@fl@bottom}%
     \begingroup
        \let \@elt \@xtryfc
        \@trylist
     \endgroup
     \if@fcolmade
        \sdh@debug{Making a float column}%
        \@vtryfc #1%
     \fi
  \fi
}
\def \sdh@testfp #1{%
  % \ifodd\c@page\@testtpg#1\fi
   \@boxfpsbit #1 8\relax % Really #1 8 for human readers!
   \ifodd \@tempcnta
   \else
     \@testtrue
   \fi
}
\def\sdh@makefcol{\@fpmin0\p@\let\@testfp\@gobble}
\def\sdh@map#1<-#2#3{%
  % #2 is function, #3 is source, #1 is destination
  % Function must return a single unit
  \def\@elt##1{\xa\noexpand\xa\@@elt#2##1}%
  \edef#1{#3}\let\@elt\relax\def\@@elt{\@elt}\edef#1{#1}%
}

\def\@tryfcolumn#1{%
  \begingroup
  \ifsdh@floatbarrier\sdh@makefcol\fi
  %\def\@bitor{\@testfalse\@gobbletwo}% actually do it!
  \sdh@debug{\string\@tryfcolumn: \meaning\sdh@fl@defer}%
  \sdh@map\@temp@<-\@fourthoffour\sdh@fl@defer
  \let\sdh@save@freelist\@freelist
  \let\@freelist\@empty
  \sdh@debug{@temp@: \meaning\@temp@}%
  \let\@elt\relax
  \sdh@old@tryfcolumn\@temp@
  \let\sdh@pagelist\@freelist
  \sdh@cat\@freelist:=\sdh@pagelist\sdh@save@freelist
  % Now \@freelist is the list of boxes we added to this page
  \if@fcolmade
    \sdh@debug{FLOAT PAGE: \meaning\sdh@pagelist}%
    % \sdh@fl@here better be empty or something is fishy.
    \ifx\sdh@fl@here\@empty\else\sdh@error{Here list should be empty}\@eha\fi
    \def\@elt##1{\sdh@move##1\sdh@fl@defer\sdh@fl@here}\sdh@pagelist
    % \sdh@renumberfigures gets called by \@outputpage via \@opcol
  \fi
  \endgroup
}
\Inline*\def\@makecol{%
  %\sdh@debug{@makecol height: \the\ht\@cclv}%
  \@makecol
}
\Inline*\def\@startcolumn{\@startcolumn
  \sdh@debug{@startcolumn}%
  % sdh 5/30/08 - we don't want to checkdeffered if we just made a float page
  % -> combinefloats won't get run until the next page, but then we haven't
  % accounted for the height of the float so it'll run off the page!
  \if@fcolmade\else\global\sdh@floatpagefalse\sdh@check@deferred\fi}
\def\@addtocurcol{%
  \sdh@debug{Request to add float \@currbox}%
  %\sdh@debug{\vsize=\the\vsize, \@colroom=\the\@colroom}%
  \@setfloattypecounts % sets \@fpstype
  \sdh@which@fps
  %\sdh@debug{Soon: sdh@dofps = \meaning\sdh@dofps}%
  \sdh@checkfloatsize %\sdh@checkdeferred
  %\sdh@debug{Next: sdh@dofps = \meaning\sdh@dofps}%
  \sdh@dofps
}
 %\def\@doclearpage{%
 %  \sdh@debug{doclearpage}
 %  \sdh@old@doclearpage
 %  \ifnum\outputpenalty<-10000\sdh@disorderedfloats\fi
 %}
 \Inline*\def\@specialoutput{%
   %\sdh@debug{botlist: \meaning\@botlist}%
   \sdh@debug{***specialoutput \the\outputpenalty: \@currlist}%
 %%%% This was supposed to allow really nice OR injection... :-/
 %  \ifnum\outputpenalty=-10005%\@Mv % custom routine!
 %    \message{^^Jhmm}%
 %      \global \setbox\@holdpg \vbox{%
 %                \unvbox\@holdpg
 %                \unvbox\@cclv
 %                \setbox\@tempboxa \lastbox
 %                \unskip
 %         }%
 %      \@pagedp \dp\@holdpg
 %      \@pageht \ht\@holdpg
 %    \message{^^J\the\@pageht}%
 %      \unvbox \@holdpg
 %    \the\sdh@outputcode
 %      \@reinserts
 %      \ifnum \outputpenalty<\z@
 %        \if@nobreak
 %          \nobreak
 %        \else
 %          \addpenalty \interlinepenalty
 %        \fi
 %      \fi
 %    \global\sdh@outputcode{}%
 %  \else\sdh@old@specialoutput\fi
  \@specialoutput
   %\begingroup\countlist\@currlist
   %\ifnum\count@>\z@\sdh@warning{Extra float(s) in \string\@specialoutput\space
   %  on page \the\c@page: \sdh@floatnums}\fi
   %\endgroup
   %\sdh@debug{botlist: \meaning\@botlist}%
 }
 %\let\sdh@old@topnewpage\@topnewpage
 %\def\@topnewpage{\sdh@debug{topnewpage}\sdh@old@topnewpage}
\Inline*\def\refstepcounter#1{%
  \begingroup\edef\@temp@{#1}%
  \ifx\@temp@\@captype\endgroup % Yes, \@captype tells us to proceed
    \xa\let\xa\@@\csname c@\@captype\endcsname % \@@ <- \c@#1
    \xa\def\xa\@@@\xa{\csname sdh@c@\@captype\endcsname} % \@@@ <- \sdh@c@#1
    % Step 1: Check if this is the first time we've been called on this type
    \xa\ifx\@@@\relax
      \xa\xdef\@@@{0}% Yes, so we need to define \sdh@c@#1
    \fi
    % Step 2: Construct a UFI
    \edef\this@ufi{\sdh@make@ufi}%
    \xa\let\xa\this@newnum\csname newnum@\this@ufi\endcsname
    % Step 3: Add the UFI and the ORIGINAL number to the UFI list
    \begingroup
      \edef\@temp@{{{{\this@ufi}{\the\@@}}}}%
      \xa\@cons\xa\sdh@ufilist\@temp@
    \endgroup
      %\sdh@debug{ufilist: \sdh@ufilist}%
    % Step 4: Figure out if we've got a correction or not
    %         -> \@@ now has the (hopefully) correct value
    \ifx\this@newnum\relax\else % We've seen this before: use the real value
      %\sdh@debug{CORRECTING \the\@@ -> \this@newnum}%
      \xa\@@\this@newnum % Use the saved value
    \fi
    % Step 5: Increment \sdh@c@#1
    \xa\xa\xa\count@\@@@ % get \the\@@@, effectively
    \advance\count@\@ne
    \xa\xdef\@@@{\the\count@}%
    % Now do normal refstep
  \else\endgroup\fi % funny nesting here!
  \Super % do normal step now for everybody!
}
\Inline*\def\@stpelt#1{\Super\sdh@zerocounter{#1}}
\Inline*\def\end@float{%
  \begingroup
    %\sdh@debug{endfloat(\@currbox): \sdh@ufilist}%
    \ifx\@captype\undef % take a stab at defining a \@captype
      \def\eat##1:##2\x{##1}%
      \def\@elt##1{\edef\@captype{\xa\eat\@firstoftwo##1\x}}%
      %\sdh@debug{ => \sdh@ufilist}%
      \sdh@ufilist
      \let\@elt\relax
      %\sdh@debug{ => \sdh@ufilist}%
    \fi
    \ifx\@captype\undef % 5/31/08 - does this ever happen?!?
      %\sdh@debug{skipped float: \@currbox}
      %\sdh@error{This should never happen?  pending skipped!}\@eha
      \sdh@addpending@nocaptype
    \else
      %\sdh@debug{ => \@captype -- \sdh@ufilist}%
      \sdh@addpending
    \fi
    %\ifsdh@counterstepped
    %  \xa\let\xa\@@\csname c@\@captype\endcsname
    %  \global\@@\sdh@holdfloatnum % Restore the state here...
    %  \global\sdh@countersteppedfalse
    %\fi
  \endgroup
 % \ifinner %% sdh - I don't know why this isn't the case?!
 %   \sdh@error{Cannot call out floats from an inner mode}\@eha
 % \fi
  \global\let\sdh@last@currbox\@currbox % doesn't look like we use this?
  \gdef\sdh@fl@inline{\sdh@fl@here}%
  \global\let\sdh@ufilist\@empty % still need this so can capture fixed captions
  \let\@captype\undef
  \end@float % used to be at the end...
  \sdh@adjustpendingwidth
  \ifsdh@disorderfloat
    \count@\count\@currbox\divide\count@\@xxxii\multiply\count@\@xxxii
    \global\advance\count\@currbox-\count@
  \fi
  \sdh@disorderfloatfalse
}

\def\thisfloatdisordered{\global\sdh@disorderfloattrue}

\def\sdh@foreach#1#2{%
  \let\@list#1%
  \def\@code@{#2}%
  \sdh@foreach@
}
\def\sdh@foreach@{%
  \def\@cont@{\sdh@foreach@}%
  \@next\@temp@\@list{\xa\xa\xa\@code@\@temp@}{\let\@cont@\relax}%
  \@cont@
}

\def\sdh@clearufilist{%
  % if we've got something here, it's from a fixed caption - deal with it...
  % difficulty: correct ordering between [h] floats and fixeds.
  % Solution for now: leave behavior unspecified.  But we do want to increment
  % the counters, at least!  So call this on new pages and whenever we start a
  % float.
  \begingroup
    \def\eat##1:##2\x{##1}% this is handy for pulling out the \@captype
    \def\process##1##2{%
      \edef\@captype{\eat##1\x}%
      \edef\@temp@{{{{\@captype}{}%
                     {\noexpand\@elt{{##1}{##2}}}\relax}}}% no box...
      %\message{^^J===\space\space ADDING TO HERE: \@temp@}%
      \xa\@cons\xa\sdh@fl@here\@temp@%
      %\message{^^J===\space\space HERE: \sdh@fl@here}%
    }%
    \sdh@foreach\sdh@ufilist\process
    \global\let\sdh@ufilist\@empty
  \endgroup
}

\Inline*\def\@xfloat#1[#2]{%
  \sdh@countersteppedfalse
  \gdef\sdh@fl@inline{\sdh@fl@pending}%
  \sdh@clearufilist % also need one in marginpar!!
  \sdh@debug{***adding a float}%
  \global\sdh@disorderfloatfalse
  \Super
}
\def\sdh@build@tb{}
\def\sdh@check@deferred{%
  % What we need to do is add as many figures as we can.
  % How do t's and b's ever turn into p's??
  % (1) if we call \dumpfloats, it should happen automatically now?
  % (2) if the size of a single float exceeds textfraction limitations
  %     then we know there won't be any text... then what?
  %     Can we then play with \if@fcolmade (or whatever)?
  %%%%%%%
  % It looks like \@tryfcolumn is happening TWICE!
  \sdh@debug{check@deferred}%
  \let\sdh@prev@defer\sdh@fl@defer
  \let\sdh@fl@defer\@empty
  \begingroup
    \@tempswatrue % used to just use \@whilesw\ifsdh@floatfits
    \@whilesw\if@tempswa\fi{%
      % Problem here: we stop looking prematurely - there may be a
      % small enough float LATER that can go in...
      \@next\@temp@\sdh@prev@defer{%
        %\sdh@debug{\@temp@}%
        \edef\@currbox{\xa\@fourthoffour\@temp@}%
        \edef\@temp@{{{\@temp@}}}%
        \xa\@cons\xa\sdh@fl@pending\@temp@
        \@addtocurcol
      }\@tempswafalse % used to be \sdh@floatfitsfalse
    }%
  \endgroup
  \sdh@cat\sdh@fl@defer:=\sdh@fl@defer\sdh@prev@defer
}
\def\sdh@renumberfigures{%
  % We already freed the here figures...? so their counter values
  % may be hosed!
  \sdh@debug{Renumbering figures}%
  \sdh@showlists
  % Basically we need to get the counting mechanism in place for this
  % After we're done, we need to clear what we've already set...
  %
  % We could implement mergesort here to put everything into a vertical
  % list.  And/or define \@leftcol and \@rightcol, one to be empty and
  % the other to be the marginlist.
  \sdh@clearufilist
  \begingroup
    %\message{^^J===FLOAT LIST (\the\c@page): \sdh@fl@top || \sdh@fl@here || \sdh@fl@bottom || \sdh@fl@margin}%
    %\message{^^J===COUNTS \meaning\sdh@floatcounts}%
    \def\@elt##1{% outer \@elt's (float list)
      \def\@null{{}}%
      \edef\@captype{{\@firstoffour##1}}%
      \ifx\@null\@captype\else
      \begingroup % inner \@elt's (ufi lists)
        \def\@elt####1{%
          %\sdh@debug{*** in an elt: ####1}%
          \edef\@ufi{\@firstoftwo####1}%
          \xa\sdh@getcount\xa\@tempcnta\@captype
          \xa\count@\@secondoftwo####1\relax
          % If we want to only save some of the numbers, then we need to
          % save more information in the ufilist, particularly whether
          % the current number depended on being assigned...
          % ALTERNATELY, we could just store it there!
          \ifnum\count@=\@tempcnta % Do we need to change something?
            %\message{^^J===\space\space NO RENUMBER \@ufi=\the\@tempcnta}%
          \else
            %%%% Figure out if we need to warn
            %\message{^^J===\space\space RENUMBERING \@ufi->\the\@tempcnta}%
            \xa\let\xa\@newnum\csname newnum@\@ufi\endcsname
            \ifx\@newnum\relax
              \sdh@floats@disordered
            \else
              \xa\ifnum\@newnum=\@tempcnta\else
                \sdh@floats@disordered
              \fi
            \fi
            % OK, now just write the aux file
            % I'm not sure what effect \protected@write has instead, but
            % it doesn't seem to work, either on \@mainaux or \@auxout.
            \immediate\write\@auxout{%
              \string\expandafter\gdef
                \string\csname\space newnum@\@ufi\string\endcsname
                                     {\the\@tempcnta}}%
          \fi
          \xa\sdh@stepcount\@captype
        }\@thirdoffour##1% run the UFIs
      \endgroup\fi
    }%
  \ifodd\c@page % run in order
    \sdh@fl@top\sdh@fl@here\sdh@fl@bottom\sdh@fl@margin
  \else
    \sdh@fl@margin\sdh@fl@top\sdh@fl@here\sdh@fl@bottom
  \fi
  \endgroup
  \sdh@debug{Emptying here,top,bottom,margin}%
  \global\let\sdh@fl@here\@empty
  \global\let\sdh@fl@top\@empty
  \global\let\sdh@fl@bottom\@empty
  \global\let\sdh@fl@margin\@empty
  %\message{^^J===ENDCOUNTS \meaning\sdh@floatcounts^^J===}%
}
\def\sdh@which@fps{%
  \sdh@debug{float[\the\@fpstype]}
  \ifodd\@fpstype
    \sdh@checkbit\sixt@@n\@fpstype\if@test
      \let\sdh@dofps\sdh@float@h
      \sdh@debug*{-> float[h]}%
    \else
      \let\sdh@dofps\sdh@float@hh
      \sdh@debug*{-> float[h!]}%
    \fi
  \else
    % not an h
    \sdh@checkbit\tw@\@fpstype\if@test
      \sdh@checkbit\f@ur\@fpstype\if@test
        \let\sdh@dofps\sdh@float@tb
        \sdh@debug*{-> float[tb]}%
      \else
        \let\sdh@dofps\sdh@float@t
        \sdh@debug*{-> float[t]}%
      \fi
    \else
      \sdh@checkbit\f@ur\@fpstype\if@test
        \let\sdh@dofps\sdh@float@b
        \sdh@debug*{-> float[b]}%
      \else
        % not t or b
        \sdh@checkbit\sixt@@n\@fpstype\if@test
          \let\sdh@dofps\sdh@float@p
          \sdh@debug*{-> float[p]}%
        \else
          \let\sdh@dofps\sdh@float@pp
          \sdh@debug*{-> float[p!]}%
        \fi
      \fi
    \fi
  \fi
  % Will this work? - it seems to work ok...?
  %\ifsdh@floatbarrier\let\sdh@dofps\sdh@float@p\fi
}
\def\sdh@float@hh{\sdh@float@h}
\def\sdh@float@pp{\sdh@float@p}
\def\sdh@float@t{\sdh@float@b}
\def\sdh@float@tb{\sdh@float@b}
\def\sdh@float@h{%
  \ifsdh@floatfits
    \sdh@debug{h float fits: \@currbox}%
    % stolen from original @addtocurcol
    \if@nobreak
      \nobreak
      \@nobreakfalse
      \everypar{}%
    \else
      \addpenalty \interlinepenalty
    \fi
    \vskip\intextsep
    \sdh@addfloattocolumn
    % end stolen code
    \sdh@free\@currbox
  \else
    \sdh@debug{h float doesn't fit: \@currbox}%
    \sdh@deferfloat
    \vfill\penalty-\@M % output the page?
    % We might want to instead conver to 't', etc.
  \fi
}
\def\sdh@float@b{%
  \ifsdh@floatfits
    \sdh@debug{b float fits: \@currbox}%
    \sdh@move\@currbox\sdh@fl@pending\sdh@fl@bottom
    %\sdh@debug{colroom=\the\@colroom, size=\the\@tempdima}%
    %\global\advance\@colroom-\@tempdima % (other skips?)
    %\sdh@debug{colroom (after)=\the\@colroom}
    %%\global\advance\vsize-\@tempdima % (other skips?)
    %\global\vsize\@colroom
    %\@cons\@botlist\@currbox
    \global\maxdepth\z@ % this is LaTeX's method
    \@flupdates\@botnum\@botroom\@botlist
    %\sdh@tryfullwidth
  \else
    \sdh@debug{b float doesn't fit: \@currbox}%
    \sdh@move\@currbox\sdh@fl@pending\sdh@fl@defer
  \fi
  %\sdh@debug{botlist: \meaning\@botlist}%
}
\def\sdh@float@p{%
  \sdh@debug{Checking p float for injection: \meaning\@currbox\space
    vs. \meaning\sdh@injectbox}%
  \ifx\@currbox\sdh@injectbox %%%% OR injection code
    \@cons\@freelist\@currbox
    \let\sdh@trash\@empty
    \sdh@move\@currbox\sdh@fl@pending\sdh@trash
    \the\sdh@outputcode
    \global\sdh@outputcode{}%
    \global\let\sdh@injectbox\relax
  \else %%%% NORMAL CODE
    \sdh@debug{p float: \@currbox}%
    \@testfalse
    \ifsdh@floatpage \ifsdh@floatfits \@testtrue \fi \fi
    \if@test % this is a float page and it fits...
    % But I don't think we use this mechanism anymore!
      \UNUSED@CODE@IN@FLOAT@P
      \sdh@debug*{ -> fits}%
      %\sdh@debug{p float fits: \@currbox}%
      \sdh@move\@currbox\sdh@fl@pending\sdh@fl@bottom
      %\sdh@debug{colroom=\the\@colroom, size=\the\@tempdima}%
      %\global\advance\@colroom-\@tempdima % (other skips?)
      %\sdh@debug{colroom (after)=\the\@colroom}
      %%\global\advance\vsize-\@tempdima % (other skips?)
      %\global\vsize\@colroom
      %\@cons\@botlist\@currbox
      \global\maxdepth\z@ % this is LaTeX's method
      \@flupdates\@botnum\@botroom\@botlist
      %\sdh@tryfullwidth
    \else
      \sdh@debug*{ -> deferred}%
      %\sdh@debug{p float doesn't fit: \@currbox}%
      \sdh@move\@currbox\sdh@fl@pending\sdh@fl@defer
    \fi
 \fi
}
\def\sdh@checkfloatsize{%
  \sdh@floatfitstrue
  \sdh@debug{checkfloatsize \@currbox}%
  % Sizes
  \begingroup
    \@tempdima\dimexpr\ht\@currbox+\dp\@currbox\relax
    \@tempdimb\dimexpr\@colroom-\@pageht\relax
    \sdh@debug{float: \the\@tempdima^^J***space:\the\@tempdimb}%
    \ifdim\@tempdima>\@tempdimb
      \aftergroup\sdh@floatfitsfalse
          \sdh@debug{failed: height}%
    \fi
  % Number (for now only count top/bottom - could be separate)
  % This needs to not happen if we;re on a float page
  % -> how do we tell if we've run out of text?!?
  % if no text then pull it OUT of \@botlist and instead put
  % it in the page...?
    \ifx\sdh@dofps\sdh@float@h\else % not for here floats!
      \count@\z@
      \def\@elt##1{\advance\count@\@ne}\sdh@fl@top\sdh@fl@bottom
      \ifnum\count@<\floatsperpage\else
        \ifsdh@floatpage\else
          \aftergroup\sdh@floatfitsfalse
          \sdh@debug{failed: count}%
        \fi
      \fi
    \fi
  % Finally, make sure that we're not messing up the order...
    \sdh@map\@temp@<-\@fourthoffour\sdh@fl@defer
    % copied from \@?tryfc
    \@currtype \count \@currbox
    \divide\@currtype\@xxxii
    \multiply\@currtype\@xxxii
    \@bitor \@currtype \@temp@
    \if@test\sdh@debug{failed: blocked (\the\@currtype)}\aftergroup\sdh@floatfitsfalse\fi
  \endgroup
  %
}
\def\sdh@addfloattocolumn{%
  \sdh@debug{adding a float to the column: \@currbox}
  % We're in the output routine already.  If this is an overfull
  % box, then add margin blockers...
  % One problem we run into here is that an overflowing [h] float at the
  % top of a page will be numbered AFTER the left-hand margin figures,
  % which is confusing.  If we could somehow insert ALL the floats into
  % the margin float list, giving preference for before/after to even/odd
  % pages, then we could have a truly ``top-down'' approach to numbering...
  % but this is a bit tricky.  All we need to do is merge-sort...!
  \ifdim\wd\@currbox>\columnwidth
    \sdh@tryfullwidth\@currbox % shift it over if even page
    \begingroup
    \edef\@temp@{{%
        {{\the\@pageht}{\the\dimexpr\@pageht+\ht\@currbox+\dp\@currbox}}%
    }}% what about skips?
    \xa\@cons\xa\sdh@marginphantom\@temp@
    \endgroup
  \fi
  % Now actually insert the box
  \box\@currbox
  \penalty\interlinepenalty
  \vskip\intextsep
  \ifnum\outputpenalty <-\@Mii \vskip-\parskip\fi
  \sdh@move\@currbox\sdh@fl@pending\sdh@fl@here
}
\def\sdh@undeferfloat#1{%
  \sdh@debug{undeferring #1}%
  %\@push\sdh@currlist@deferred#1%
  %\ifx\@currlist\sdh@currlist@deferred\else
  %  \sdh@error{Need to afterall: \@currlist vs \sdh@currlist@deferred}\@eha\fi
  %\global\let\@currlist\sdh@currlist@deferred
  \@push\@currlist#1%
  %\global\let\sdh@currlist@deferred\@empty
  % Maybe we should call \@addtocurcol directly?
  %\sdh@debug{ currlist=\@currlist}%
  %\sdh@debug{ pending=\sdh@fl@pending}%
  \penalty-\@Miv\@tempdima\prevdepth\vbox{}\prevdepth\@tempdima\penalty-\@Miii
}

\def\sdh@deferfloat{%
  %% This currently is only used by [h] floats that don't fit.  We should
  %% probably instead put something into the \@startcolumn code for this...
  \sdh@debug{deferring a float: \@currbox}%
  %\sdh@debug{ currlist=\@currlist}%
  %\sdh@debug{ pending=\sdh@fl@pending}%
  %\@cons\sdh@currlist@deferred\@currbox
  %\global\let\sdh@currlist@deferred\@currlist % might not need this at all???
  %\let\@currlist\@empty
  \global\sdh@afterpage\xa\xa\xa{% push front for correct order and in front
    \xa\xa\xa\sdh@undeferfloat\xa\@currbox\the\sdh@afterpage}
  %\sdh@debug{ afterpage=\the\sdh@afterpage}%
}
\def\sdh@addpending{%
  \sdh@debug{addpending: \@captype(\@currbox)--\sdh@ufilist}%
  \begingroup
  \edef\@temp@{{{\@captype}{\noexpand\noexpand\noexpand\the\wd\@currbox}%
                {\sdh@ufilist}\@currbox}}%
  \xa\@cons\sdh@fl@inline{\@temp@}%
  \endgroup
  %\sdh@showlists
}
\def\sdh@addpending@nocaptype{%
  \sdh@debug{addpending nocaptype}%
  \begingroup
  \edef\@temp@{{{}{\noexpand\noexpand\noexpand\the\wd\@currbox}%
                {}\@currbox}}%
  \xa\@cons\sdh@fl@inline{\@temp@}%
  \endgroup
  %\sdh@showlists
}
\def\sdh@adjustpendingwidth{%
  %\message{^^J===BEFORE: \sdh@fl@pending}%
  \begingroup\let\@elt\relax\xdef\sdh@fl@pending{\sdh@fl@pending}\endgroup
  %\message{^^J===AFTER: \sdh@fl@pending}%
}
\def\sdh@tryfullwidth#1{%
  \sdh@debug{TFW(#1, page \the\c@page): \the\wd#1}%
  \ifdim\wd#1>\columnwidth
    \begingroup
    \@tempdima\dimexpr\textwidth + \marginparsep + \marginparwidth\relax
    \ifdim\wd#1>\@tempdima
      \sdh@warning{Float box wider than page width %
        (\the\wd#1>\the\@tempdima)}
    \fi\endgroup
    % We used to have the following in an \else, but that means that
    % it won't even try to fix it if it's too big.  Now, it just has
    % the overflow go out to the left instead...
    \ifodd\c@page\sdh@debug{even page textwidth}\else
      %\sdh@debug{fullwidth box: \the\wd\@currbox, \the\columnwidth}%
      \@tempdima\dimexpr \wd#1 - \columnwidth \relax
      \sdh@debug{moving \the\@tempdima}%
      \global\setbox#1=\vbox{\moveleft\@tempdima\box#1}% unskip?
      %\setbox\@currbox\hbox{\hskip-\@tempdima\box\@currbox}%
    \fi
  \fi
}
 %\let\sdh@tryfullwidth\relax
 %% %%%%
 %% % First assumption: there are no blocks...  ignore ! in fps,
 %% % fit the float whereever there's space...
 %% \def\sdh@blocks#1#2{%
 %%   % pass in two numbers - does #2 block #1?  here we take into
 %%   % account (a) same float type
 %% }

 %% \def\sdh@lookforblock#1{%
 %%   % if #1 is 'h' then a 'b' on the same page blocks, but a 't' doesn't
 %%   % if #1 is 't' then a 'b' and a 'h' on the same page blocks...?
 %%   % if #1 is 'b' then only another 'b' blocks?
 %% }

 %% \def\sdh@bitor#1{%
 %%   \@testfalse{%
 %%     \def\fl@float##1{\@xbitor}\@tempcnta #1\relax}}
\makeatother



\endinput
%%
%% End of file `marginfix.sty'.
